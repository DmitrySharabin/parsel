<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Parsel: A tiny, permissive CSS selector parser</title>
	<link rel="shortcut icon" href="favicon.svg">
	<link rel="stylesheet" href="style.css">
</head>
<body>

<header>
	<h1>parsel</h1>
	<h2>A tiny, permissive CSS selector parser</h2>

	<ul>
		<li>Parse & traverse CSS selectors</li>
		<li>Calculate specificity</li>
		<li>Only 2KB and no dependencies</li>
		<li>Supports the entire <a href="https://w3.org/TR/selectors-4">Selectors 4</a> syntax</li>
		<li>Permissive enough to work with a lot of potential future syntax</li>
	</ul>
</header>

<section id="tryout">
	<header>
		<label>
			Selector:
			<input type="text" id="selectorText" value="#foo > .bar + div.k1.k2 [id='baz']:hello(2):not(:where(#yolo))::before">
		</label>
		<label>
			<input type="checkbox" id="recursive" checked>
			Recursive (parse arguments of <code>:not()</code>, <code>:is()</code>, <code>:where()</code> etc)
		</label>
		<div>Specificity: <strong id="specificity"></strong></div>
	</header>
	<article>
		<h2>Tokens</h2>
		<pre><code>parsel.tokenize(selector);</code></pre>
		<pre id="tokens"></pre>
	</article>
	<article>
		<h2>AST</h2>
		<pre><code>parsel.parse(selector);</code></pre>
		<pre id="tree"></pre>
	</article>
</section>

<section>
	<h2>Usage</h2>

	<p>Parsel is an ES module. You import it like so:</p>

	<pre><code>import * as parsel from "https://leaverou.github.io/parsel.js"</code></pre>

	<p>Note that to use that your script needs to use <code>type="module"</code> or be imported from a script that does.
		If you can't use ES modules, here is a workaround to convert Parsel to a global:
	</p>

	<pre><code>
		&lt;script type="module">
			import * as parsel from "https://leaverou.github.io/parsel.js";
			window.parsel = parsel;
		&lt;/script>
	</code></pre>

	<p>After that, you can use <code>parsel</code> as a global, assuming your code runs after the <code>DOMContentLoaded</code> event.
		In fact, we are assigning <code>parsel</code> to a global in this very page, so you can open your console and play with it!</p>

</section>

<section>
	<h2>API</h2>

	<p>Get list of tokens as a flat array:</p>

	<pre><code>parsel.tokenize(selector)</code></pre>

	<p>Get AST:</p>

	<pre><code>parsel.parse(selector)</code></pre>

	<p>You can also provide options:</p>

	<pre><code>parsel.parse(selector, {recursive: false, list: false})</code></pre>

	<p>The <code>recursive</code> option parses the arguments of pseudo-classes whose argument is a selector like <code>:not()</code>, <code>:is()</code>, <code>:where()</code> etc into a <code>subtree</code> property.
	The <code>list</code> option parses selector lists (<code>A, B, C</code>). The only reason to turn it off is as a performance optimization when you are processing a large volume of selectors that are not lists (e.g. the output of certain CSS parsers like Rework)</p>

	<p>Traverse all tokens of a (sub)tree:</p>

	<pre><code>parsel.walk(node, callback)</code></pre>

	<p>Calculate specificity (returns an array of 3 numbers):</p>

	<pre><code>parsel.specificity(selectorOrNode)</code></pre>
</section>

<script type="module">
import * as parsel from "./parsel.js";
self.parsel = parsel; // so that people can experiment in the console

(tryout.oninput = e => {
	tokens.textContent = JSON.stringify(parsel.tokenize(selectorText.value), null, "\t");

	try {

		tree.textContent = JSON.stringify(parsel.parse(selectorText.value, {recursive: recursive.checked}), null, "\t");
		tree.classList.remove("error");
		specificity.textContent = parsel.specificity(selectorText.value);
	}
	catch (e) {
		tree.classList.add("error");
		tree.innerHTML = `<details><summary>${e}</summary>${e.stack.replace(e, "")}</details>`;
	}
})();
</script>
</body>
</html>
